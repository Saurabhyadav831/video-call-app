<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Test</title>
    <!-- Auto-redirect to HTTPS for camera access -->
    <script>
      if (window.location.protocol === 'http:' && !window.location.hostname.includes('localhost')) {
        const httpsUrl = window.location.href.replace('http:', 'https:').replace(':8080', ':8443');
        window.location.href = httpsUrl;
      }
    </script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .log { background: #f0f0f0; padding: 10px; margin: 10px 0; height: 200px; overflow-y: scroll; }
        video { width: 300px; height: 225px; margin: 10px; border: 1px solid #ccc; }
        button { margin: 5px; padding: 10px; }
    </style>
</head>
<body>
    <h1>WebRTC Connection Test</h1>
    <div>
        <button onclick="startTest()">Start Test</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>
    <div class="log" id="log"></div>
    <div>
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <script>
        const log = document.getElementById('log');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        
        function logMessage(msg) {
            const time = new Date().toLocaleTimeString();
            log.innerHTML += `[${time}] ${msg}<br>`;
            log.scrollTop = log.scrollHeight;
            console.log(msg);
        }
        
        function clearLog() {
            log.innerHTML = '';
        }
        
        let ws, peerConnection, localStream;
        
        async function startTest() {
            try {
                logMessage('Starting WebRTC test...');
                
                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                logMessage('Got local media stream');
                
                // Create WebSocket connection
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.hostname;
                const port = window.location.protocol === 'https:' ? '8444' : '3000';
                ws = new WebSocket(`${protocol}//${host}:${port}`);
                
                ws.onopen = () => {
                    logMessage('WebSocket connected');
                    initPeerConnection();
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        logMessage(`Received: ${message.type}`);
                        handleSignalingMessage(message);
                    } catch (error) {
                        logMessage(`Error parsing message: ${error}`);
                    }
                };
                
                ws.onclose = () => {
                    logMessage('WebSocket disconnected');
                };
                
                ws.onerror = (error) => {
                    logMessage(`WebSocket error: ${error}`);
                };
                
            } catch (error) {
                logMessage(`Error: ${error.message}`);
            }
        }
        
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });
            
            // Add local tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                logMessage(`Added track: ${track.kind}`);
            });
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    logMessage('Sending ICE candidate');
                    ws.send(JSON.stringify({
                        type: 'candidate',
                        candidate: event.candidate
                    }));
                }
            };
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                logMessage('Received remote stream');
                remoteVideo.srcObject = event.streams[0];
            };
            
            // Handle connection state
            peerConnection.onconnectionstatechange = () => {
                logMessage(`Connection state: ${peerConnection.connectionState}`);
            };
            
            // Handle ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                logMessage(`ICE connection state: ${peerConnection.iceConnectionState}`);
            };
            
            logMessage('Peer connection initialized');
            
            // Create offer after a delay
            setTimeout(() => {
                createOffer();
            }, 1000);
        }
        
        async function createOffer() {
            try {
                logMessage('Creating offer...');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                ws.send(JSON.stringify(offer));
                logMessage('Offer sent');
            } catch (error) {
                logMessage(`Error creating offer: ${error.message}`);
            }
        }
        
        async function handleSignalingMessage(message) {
            switch (message.type) {
                case 'client-id':
                    logMessage(`Client ID: ${message.id}`);
                    break;
                    
                case 'offer':
                    logMessage('Handling offer');
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(message));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify(answer));
                    logMessage('Answer sent');
                    break;
                    
                case 'answer':
                    logMessage('Handling answer');
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(message));
                    break;
                    
                case 'candidate':
                    logMessage('Adding ICE candidate');
                    await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                    break;
                    
                case 'peer-disconnected':
                    logMessage('Peer disconnected');
                    break;
            }
        }
    </script>
</body>
</html> 