<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Test</title>
    <link href="/css/styles.css" rel="stylesheet">
    <!-- Auto-redirect to HTTPS for camera access -->
    <script>
      if (window.location.protocol === 'http:' && !window.location.hostname.includes('localhost')) {
        const httpsUrl = window.location.href.replace('http:', 'https:').replace(':8080', ':8443');
        window.location.href = httpsUrl;
      }
    </script>
</head>
<body class="font-sans m-5">
    <h1 class="text-3xl font-bold mb-5">WebRTC Connection Test</h1>
    <div class="mb-4">
        <button class="bg-blue-500 text-white px-4 py-2 rounded mr-2 hover:bg-blue-600" onclick="startTest()">Start Test</button>
        <button class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600" onclick="clearLog()">Clear Log</button>
    </div>
    <div class="bg-gray-100 p-3 mb-4 h-48 overflow-y-scroll border rounded" id="log"></div>
    <div class="flex gap-4">
        <video id="localVideo" autoplay muted playsinline class="w-80 h-60 border border-gray-300 rounded"></video>
        <video id="remoteVideo" autoplay playsinline class="w-80 h-60 border border-gray-300 rounded"></video>
    </div>

    <script>
        const log = document.getElementById('log');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        
        function logMessage(msg) {
            const time = new Date().toLocaleTimeString();
            log.innerHTML += `[${time}] ${msg}<br>`;
            log.scrollTop = log.scrollHeight;
            console.log(msg);
        }
        
        function clearLog() {
            log.innerHTML = '';
        }
        
        let ws, peerConnection, localStream;
        
        async function startTest() {
            try {
                logMessage('Starting WebRTC test...');
                
                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                logMessage('Got local media stream');
                
                // Create WebSocket connection
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.hostname;
                const port = window.location.protocol === 'https:' ? '8444' : '3000';
                ws = new WebSocket(`${protocol}//${host}:${port}`);
                
                ws.onopen = () => {
                    logMessage('WebSocket connected');
                    initPeerConnection();
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        logMessage(`Received: ${message.type}`);
                        handleSignalingMessage(message);
                    } catch (error) {
                        logMessage(`Error parsing message: ${error}`);
                    }
                };
                
                ws.onclose = () => {
                    logMessage('WebSocket disconnected');
                };
                
                ws.onerror = (error) => {
                    logMessage(`WebSocket error: ${error}`);
                };
                
            } catch (error) {
                logMessage(`Error: ${error.message}`);
            }
        }
        
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });
            
            // Add local stream
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
                logMessage('Got remote stream');
            };
            
            // ICE candidate handling
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                logMessage(`ICE connection state: ${peerConnection.iceConnectionState}`);
            };
            
            logMessage('Peer connection initialized');
        }
        
        async function handleSignalingMessage(message) {
            switch (message.type) {
                case 'offer':
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify({
                        type: 'answer',
                        answer: answer
                    }));
                    break;
                    
                case 'answer':
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                    break;
                    
                case 'ice-candidate':
                    await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                    break;
            }
        }
        
        // Create offer for testing
        async function createOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            ws.send(JSON.stringify({
                type: 'offer',
                offer: offer
            }));
            logMessage('Created and sent offer');
        }
        
        // Auto-create offer after a delay
        setTimeout(() => {
            if (peerConnection) {
                createOffer();
            }
        }, 2000);
    </script>
</body>
</html> 