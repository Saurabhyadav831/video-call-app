<!DOCTYPE html>
<html>
<head>
    <title>Video Call Debug</title>
    <link href="/css/styles.css" rel="stylesheet">
</head>
<body class="font-sans m-5 bg-gray-900 text-white">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold mb-5">Video Call Debug</h1>
        
        <div class="bg-gray-800 p-3 mb-5 rounded" id="status">Initializing...</div>
        
        <div class="flex gap-5 mb-5">
            <div>
                <h3 class="text-lg font-semibold mb-2">Local Video</h3>
                <video id="localVideo" autoplay muted playsinline class="w-96 h-72 border-2 border-gray-600 bg-black"></video>
            </div>
            <div>
                <h3 class="text-lg font-semibold mb-2">Remote Video</h3>
                <video id="remoteVideo" autoplay playsinline class="w-96 h-72 border-2 border-gray-600 bg-black"></video>
            </div>
        </div>
        
        <div class="mb-5">
            <button class="bg-green-500 text-white border-none px-5 py-2 mr-2 cursor-pointer hover:bg-green-600" onclick="startTest()">Start Test</button>
            <button class="bg-green-500 text-white border-none px-5 py-2 cursor-pointer hover:bg-green-600" onclick="clearLog()">Clear Log</button>
        </div>
        
        <div class="bg-black text-green-400 p-3 h-72 overflow-y-scroll font-mono text-xs border border-gray-600" id="log"></div>
    </div>

    <script>
        const log = document.getElementById('log');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const status = document.getElementById('status');
        
        let ws, peerConnection, localStream;
        
        function logMessage(msg) {
            const time = new Date().toLocaleTimeString();
            log.innerHTML += `[${time}] ${msg}<br>`;
            log.scrollTop = log.scrollHeight;
            console.log(msg);
        }
        
        function clearLog() {
            log.innerHTML = '';
        }
        
        function updateStatus(msg) {
            status.textContent = msg;
            logMessage(`Status: ${msg}`);
        }
        
        async function startTest() {
            try {
                updateStatus('Getting user media...');
                logMessage('Starting debug test...');
                
                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                logMessage('Got local media stream');
                updateStatus('Local stream active');
                
                // Create WebSocket connection
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.hostname;
                const port = window.location.protocol === 'https:' ? '8444' : '3000';
                ws = new WebSocket(`${protocol}//${host}:${port}`);
                
                ws.onopen = () => {
                    logMessage('WebSocket connected');
                    updateStatus('WebSocket connected');
                    initPeerConnection();
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        logMessage(`Received: ${message.type}`);
                        handleSignalingMessage(message);
                    } catch (error) {
                        logMessage(`Error parsing message: ${error}`);
                    }
                };
                
                ws.onclose = () => {
                    logMessage('WebSocket disconnected');
                    updateStatus('WebSocket disconnected');
                };
                
                ws.onerror = (error) => {
                    logMessage(`WebSocket error: ${error}`);
                    updateStatus('WebSocket error');
                };
                
            } catch (error) {
                logMessage(`Error: ${error.message}`);
                updateStatus(`Error: ${error.message}`);
            }
        }
        
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });
            
            // Add local stream
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                logMessage(`Added track: ${track.kind}`);
            });
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                logMessage('Received remote stream');
                remoteVideo.srcObject = event.streams[0];
                updateStatus('Remote stream active');
            };
            
            // ICE candidate handling
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    logMessage('Sending ICE candidate');
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                }
            };
            
            // Connection state changes
            peerConnection.onconnectionstatechange = () => {
                logMessage(`Connection state: ${peerConnection.connectionState}`);
                updateStatus(`Connection: ${peerConnection.connectionState}`);
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                logMessage(`ICE connection state: ${peerConnection.iceConnectionState}`);
            };
            
            peerConnection.onicegatheringstatechange = () => {
                logMessage(`ICE gathering state: ${peerConnection.iceGatheringState}`);
            };
            
            logMessage('Peer connection initialized');
            updateStatus('Peer connection ready');
            
            // Create offer after a delay
            setTimeout(() => {
                createOffer();
            }, 1000);
        }
        
        async function createOffer() {
            try {
                logMessage('Creating offer...');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                ws.send(JSON.stringify({
                    type: 'offer',
                    offer: offer
                }));
                logMessage('Offer sent');
                updateStatus('Offer sent');
            } catch (error) {
                logMessage(`Error creating offer: ${error.message}`);
                updateStatus(`Offer error: ${error.message}`);
            }
        }
        
        async function handleSignalingMessage(message) {
            try {
                switch (message.type) {
                    case 'offer':
                        logMessage('Handling offer');
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        ws.send(JSON.stringify({
                            type: 'answer',
                            answer: answer
                        }));
                        logMessage('Answer sent');
                        break;
                        
                    case 'answer':
                        logMessage('Handling answer');
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                        break;
                        
                    case 'ice-candidate':
                        logMessage('Adding ICE candidate');
                        await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                        break;
                        
                    case 'peer-disconnected':
                        logMessage('Peer disconnected');
                        updateStatus('Peer disconnected');
                        break;
                }
            } catch (error) {
                logMessage(`Error handling message: ${error.message}`);
            }
        }
        
        // Auto-start test
        setTimeout(() => {
            startTest();
        }, 1000);
    </script>
</body>
</html> 